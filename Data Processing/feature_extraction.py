# -*- coding: utf-8 -*-
"""feature_extraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xLUlu5BixPP8JfkYuxuvKtbHGY7xgTFz
"""

# Feature Engineering - Extracting CNN Features for Drowsiness Detection

# Step 1: Install dependencies
!pip install -q tensorflow opencv-python numpy matplotlib

# Step 2: Import required libraries
import numpy as np
import tensorflow as tf
import cv2
import os
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
from tensorflow.keras.preprocessing.image import img_to_array, load_img
import matplotlib.pyplot as plt
from google.colab import drive

# Step 3: Load Preprocessed Data
drive.mount('/content/drive')
DATASET_PATH = "/content/drive/MyDrive/Colab Notebooks/AI Studio/Project/drowsiness_preprocessed_Updated.npz"
data = np.load(DATASET_PATH)
X, y = data["X"], data["y"]

print("Loaded preprocessed dataset successfully!")
print("Dataset shape before resizing:", X.shape)  # Check shape before resizing

# Define MobileNetV2 input size
IMG_SIZE = (224, 224)

# Step 4: Load MobileNetV2 as Feature Extractor
base_model = MobileNetV2(weights="imagenet", include_top=False, input_shape=(224, 224, 3))
base_model.trainable = False  # Freeze the model

# Step 5: Function for Batch Processing
def preprocess_and_extract(image_batch, model):
    features = []
    for img in image_batch:
        resized_img = cv2.resize(img, IMG_SIZE)  # Resize on-the-fly (no full dataset in RAM)
        processed_img = preprocess_input(resized_img)  # Normalize
        extracted_feature = model.predict(np.expand_dims(processed_img, axis=0), verbose=0)  # Suppress logs
        features.append(extracted_feature)
    return np.array(features)

# Step 6: Extract Features in Batches (Memory Efficient)
batch_size = 64  # Small batches prevent RAM crash
X_features_list = []  # Store features in list (to avoid high RAM usage)

for i in range(0, len(X), batch_size):
    if i % (batch_size * 8) == 0:  # Only print every 10 batches
        print(f"Processing batch {i} to {i+batch_size}")

    batch = X[i:i+batch_size]  # Take small batch
    batch_features = preprocess_and_extract(batch, base_model)  # Extract features for batch
    X_features_list.append(batch_features)

X_features = np.concatenate(X_features_list, axis=0)  # Convert list to numpy array after all batches are processed

print("Feature Extraction Completed! Feature Shape:", X_features.shape)

# Step 7: Save Features for Model Training
FEATURES_PATH = "/content/drive/MyDrive/Colab Notebooks/AI Studio/Project/drowsiness_features_updated_03.npz"
np.savez(FEATURES_PATH, X_features=X_features, Y_features=y)

# Print confirmation messages
print(f"Features Saved Successfully at: {FEATURES_PATH}")
print(f"Saved X_features shape: {X_features.shape}")  # Check X features shape
print(f"Saved Y_features shape: {y.shape}")  # Check labels shape

print("Features Saved Successfully at:", FEATURES_PATH)

data = np.load("/content/drive/MyDrive/Colab Notebooks/AI Studio/Project/drowsiness_features_updated_03.npz")
print("Loaded X_features shape:", data["X_features"].shape)
print("Loaded Y_features shape:", data["Y_features"].shape)

# Step 8: Display Sample Extracted Features (Balanced Drowsy & Awake)
plt.figure(figsize=(10, 5))

# Find indices of drowsy and awake images
drowsy_indices = np.where(y == 1)[0]  # Find indices where label = 1 (Drowsy)
awake_indices = np.where(y == 0)[0]   # Find indices where label = 0 (Awake)

# Pick 3 Drowsy and 3 Awake images (if available)
selected_indices = list(drowsy_indices[:3]) + list(awake_indices[:3])

for i, idx in enumerate(selected_indices):
    plt.subplot(2, 3, i + 1)

    # Ensure image is in uint8 format before OpenCV processing
    img_display = (X[idx] * 255).astype(np.uint8)  # Convert to uint8
    img_display = cv2.cvtColor(cv2.resize(img_display, IMG_SIZE), cv2.COLOR_BGR2RGB)  # Convert BGR to RGB

    plt.imshow(img_display)
    plt.title("Drowsy" if y[idx] == 1 else "Awake")  # Use selected index for label
    plt.axis("off")

plt.show()